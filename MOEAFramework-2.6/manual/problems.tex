% Copyright 2011-2015 David Hadka.  All Rights Reserved.
%
% This file is part of the MOEA Framework User Manual.
%
% Permission is granted to copy, distribute and/or modify this document under
% the terms of the GNU Free Documentation License, Version 1.3 or any later
% version published by the Free Software Foundation; with the Invariant Section
% being the section entitled "Preface", no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU Free
% Documentation License".

\chapter{Defining New Problems}
\label{chpt:problems}

The real value of the MOEA Framework comes not from the algorithms and tools it provides, but the problems that it solves.  As such, being able to introduce new problems into the MOEA Framework is an integral aspect of its use.

Throughout this chapter, we will show how a simple multiobjective problem, the Kursawe problem, can be defined in Java, C/C++, and in scripting languages.  The formal definition for the Kursawe problem is provided below.

\begin{equation}
  \label{eq:mop}
  \begin{aligned}
    & \underset{\vect{x} \in \mathbb{R}^L}{\text{minimize}}
      & & F(\vect{x}) = (f_1(\vect{x}), f_2(\vect{x})) \\
    & \text{where}
      & & f_1(\vect{x}) = \sum_{i=0}^{L-1} -10\text{e}^{-0.2\sqrt{x_i^2 + x_{i+1}^2}}, \\
    & & & f_2(\vect{x}) = \sum_{i=0}^{L} \left|x_i\right|^{0.8} + 5\sin\left(x_i^3\right).
  \end{aligned}
\end{equation}

\begin{important}
The MOEA Framework only works on minimization problems.  If any objectives in your problem are to be maximized, you can negate the objective value to convert from maximization into minimization.  In other words, by minimizing the negated objective, your are maximizing the original objective.  See section \ref{sect:maximizing} for additional details on dealing with maximization objectives.
\end{important}

\section{Java}
Defining new problems in Java is the most direct and straightforward way to introduce new problems into the MOEA Framework.  All problems in the MOEA Framework implement the \class{Problem} interface.  The \class{Problem} interface defines the methods for characterizing a problem, defining the problem's representation, and evaluating solutions to the problem.  In practice, you should never need to implement the \class{Problem} interface directly, but can extend the more convenient \class{AbstractProblem} class.  \class{AbstractProblem} provides default implementations for many of the methods required by the \class{Problem} interface.  The code example below shows the Kursawe problem defined by extending the \class{AbstractProblem} class.

\begin{lstlisting}[language=Java]
import org.moeaframework.core.Solution;
import org.moeaframework.core.variable.EncodingUtils;
import org.moeaframework.core.variable.RealVariable;
import org.moeaframework.problem.AbstractProblem;
 
public class Kursawe extends AbstractProblem {
 
	public Kursawe() {
		super(3, 2);
	}

	@Override
	public Solution newSolution() {
		Solution solution = new Solution(numberOfVariables, 
				numberOfObjectives);
 
		for (int i = 0; i < numberOfVariables; i++) {
			solution.setVariable(i, new RealVariable(-5.0, 5.0));
		}
 
		return solution;
	}

	@Override
	public void evaluate(Solution solution) {
		double[] x = EncodingUtils.getReal(solution);
		double f1 = 0.0;
		double f2 = 0.0;
   	 
		for (int i = 0; i < numberOfVariables - 1; i++) {
			f1 += -10.0 * Math.exp(-0.2 * Math.sqrt(
					Math.pow(x[i], 2.0) + Math.pow(x[i+1], 2.0)));
		}
 
		for (int i = 0; i < numberOfVariables; i++) {
			f2 += Math.pow(Math.abs(x[i]), 0.8) +  
					5.0 * Math.sin(Math.pow(x[i], 3.0));
		}
 
		solution.setObjective(0, f1);
		solution.setObjective(1, f2);
	}
 
}
\end{lstlisting}

Note on line 9 in the constructor, we call \java{super(3, 2)} to set the number of decision variables (3) and number of objectives (2).  All that remains is defining the \java{newSolution} and \java{evaluate} methods.

The \java{newSolution} method is responsible for instantiating new instances of solutions for the problem, and in doing so defines the decision variable types and bounds.  In the \java{newSolution} method, we start by creating a new \class{Solution} instance on lines 14-15.  Observe that we must pass the number of decision variables and objectives to the \class{Solution} constructor.  Next, we define each of the decision variables and specify their bounds on lines 17-19.  For the Kursawe problem, all decision variables are real values ranging between $-5.0$ and $5.0$, inclusively.  Finally, we complete this method by returning the \class{Solution} instance.

The \java{evaluate} method is responsible for evaluating solutions to the problem.  A solution which has been generated by an optimization algorithm is passed as an argument to the \java{evaluate} method.  The decision variables contained in this solution are set to the values specified by the optimization algorithm.  The evaluate method must extract these values, evaluate the problem, and set the objective values.

Since the Kursawe problem contains all real-valued decision variables, we can cast the decision variables to an array using the helpful methods of the \class{EncodingUtils} class on line 26.  Use of \class{EncodingUtils} is encouraged for extracting the decision variables from a solution.  Then on lines 27 to 38, we use those decision variables to evaluate the Kursawe problem.  Finally, on lines 40-41, we assign the two objectives for this problem.

At this point, the problem is completely defined and can be used with the MOEA Framework.  To use this problem with the \class{Executor}, \class{Instrumenter} and \class{Analyzer} classes introduced in \chptref{chpt:executor}, you pass a direct references to the problem class using the \java{withProblemClass} method.  For example, we can optimize the Kursawe problem we just defined with the following code:

\begin{lstlisting}[language=Java]
new Executor()
		.withProblemClass(Kursawe.class)
		.withAlgorithm("NSGAII")
		.withMaxEvaluations(10000)
		.run();
\end{lstlisting}

Note how we pass the reference to the problem with \java{Kursawe.class}.  The name of the class, \java{Kursawe}, is followed by \java{.class}.  The MOEA Framework then calls the constructor for the problem class, which in this case is the empty (no argument) constructor, and proceed to optimize the problem.

Problems can also define constructors with arguments.  For example, consider a problem that needs to load data from a file.  For this to work, define a constructor in the problem class that accepts the desired inputs.  In this case, our constructor would be called \java{public ProblemWithArgument(File dataFile) { ... }}.  You can then solve this problem as shown below.

\begin{lstlisting}[language=Java]
new Executor()
		.withProblemClass(ProblemWithArgument.class,
        new File("inputFile.txt"))
		.withAlgorithm("NSGAII")
		.withMaxEvaluations(10000)
		.run();
\end{lstlisting}

\section{C/C++}
It is often the case that the problem / model / computer simulation you are working with is written in a different programming language, such as C/C++.  With a little work, it is possible to connect that C/C++ problem to the MOEA Framework and optimize its inputs / parameters.  In the following example, we will demonstrate how to connect the MOEA Framework to a simple C program.  We continue using the Kursawe problem, which if written in C would appear as follows:

\begin{lstlisting}[language=C]
#include <math.h>

int nvars = 3;
int nobjs = 2;
 
void evaluate(double* vars, double* objs) {
	int i;
	objs[0] = 0.0;
	objs[1] = 0.0;

	for (i = 0; i < nvars - 1; i++) {
		objs[0] += -10.0 * exp(-0.2 * sqrt(
				pow(vars[i], 2.0) + pow(vars[i+1], 2.0)));
	}

	for (i = 0; i < nvars; i++) {
		objs[1] += pow(abs(vars[i]), 0.8) +  
				5.0 * sin(pow(vars[i], 3.0));
	}
}
\end{lstlisting}

Note how the \cpp{evaluate} method takes two arguments, \cpp{vars} and \cpp{objs}, which coincide with the inputs (the decision variables) and the outputs (the objective values).  Now we need to define how the \cpp{evaluate} method connects to the MOEA Framework.  This connection is established using the following code.

\begin{lstlisting}[language=C]
#include <stdlib.h>
#include "moeaframework.h"
 
int main(int argc, char* argv[]) {
	double vars[nvars];
	double objs[nobjs];

	MOEA_Init(nobjs, 0);

	while (MOEA_Next_solution() == MOEA_SUCCESS) {
		MOEA_Read_doubles(nvars, vars);
		evaluate(vars, objs);
		MOEA_Write(objs, NULL);
	}

	MOEA_Finalize();
	return EXIT_SUCCESS;
}
\end{lstlisting}

First, line 2 includes the \file{moeaframework.h} file.  This header is provided by the MOEA Framework and defines all the functions needed to communicate with the MOEA Framework.  All such functions begin with the prefix \cpp{MOEA\_}.  You can find the \file{moeaframework.h} file in the source code distribution in the folder \folder{examples/} along with additional examples.

Lines 4-18 define the main loop for the C/C++ program.  Lines 5-6 initialize the storage arrays for the decision variables and objectives.  Line 8 calls \cpp{MOEA\_Init} to initialize the communication between C/C++ and the MOEA Framework.  The \cpp{MOEA\_Init} method takes the number of objectives and constraints as arguments.  Once initialized, we can begin reading and evaluating solutions.  Line 10 loops as long as we successfully read the next solution using \cpp{MOEA\_Next\_solution()}.  Line 11 extracts the real valued decision variables, filling the array \cpp{vars}.  Line 12 invokes the \cpp{evaluate} method to evaluate the problem.  This results in the array \cpp{objs} being filled with the resulting objective values.  Line 13 writes the objectives back to the MOEA Framework.  The second argument to \cpp{MOEA\_Write} is \cpp{NULL} in this example, since the Kursawe problem is unconstrained.  This loop repeats until no more solutions are read.  At this point, the C/C++ program terminates by invoking \cpp{MOEA\_Finalize()} and exiting.  The complete source code is shown below.

\begin{lstlisting}[language=C]
#include <stdlib.h>
#include <math.h>
#include "moeaframework.h"
 
int nvars = 3;
int nobjs = 2;
 
void evaluate(double* vars, double* objs) {
	int i;
	objs[0] = 0.0;
	objs[1] = 0.0;

	for (i = 0; i < nvars - 1; i++) {
		objs[0] += -10.0 * exp(-0.2 * sqrt(
				pow(vars[i], 2.0) + pow(vars[i+1], 2.0)));
	}

	for (i = 0; i < nvars; i++) {
		objs[1] += pow(abs(vars[i]), 0.8) +  
				5.0 * sin(pow(vars[i], 3.0));
	}
}

int main(int argc, char* argv[]) {
	double vars[nvars];
	double objs[nobjs];

	MOEA_Init(nobjs, 0);

	while (MOEA_Next_solution() == MOEA_SUCCESS) {
		MOEA_Read_doubles(nvars, vars);
		evaluate(vars, objs);
		MOEA_Write(objs, NULL);
	}

	MOEA_Finalize();
	return EXIT_SUCCESS;
}
\end{lstlisting}

You can save this C code to \file{kursawe.c} and compile it into an executable.  If using the GNU C Compiler (gcc), you can compile this code with the following command on Linux or Windows.  Note that you will need both \file{moeaframework.h} and \file{moeaframework.c} in the same directory as \file{kursawe.c}.

\begin{lstlisting}[language=bash,breakatwhitespace=true]
gcc -o kursawe.exe kursawe.c moeaframework.c -lm
\end{lstlisting}

At this point, we now switch back to Java and define the problem class by extending the \class{ExternalProblem} class.  We extend the \class{ExternalProblem} class instead of the \class{AbstractProblem} class since \class{ExternalProblem} understands how to communicate with the executable we just compiled.  The code snippet below shows the complete Java class for this example.

\begin{lstlisting}[language=Java]
import org.moeaframework.core.Solution;
import org.moeaframework.core.variable.RealVariable;
import org.moeaframework.problem.ExternalProblem;

public class ExternalKursawe extends ExternalProblem {

	public ExternalKursawe() {
		super("kursawe.exe");
	}
	
	public int getNumberOfVariables() {
		return 3;
	}
	
	public int getNumberOfObjectives() {
		return 2;
	}
	
	public int getNumberOfConstraints() {
		return 0;
	}

	@Override
	public Solution newSolution() {
		Solution solution = new Solution(getNumberOfVariables(), 
				getNumberOfObjectives(), getNumberOfConstraints());
 
		for (int i = 0; i < numberOfVariables; i++) {
			solution.setVariable(i, new RealVariable(-5.0, 5.0));
		}
 
		return solution;
	}

}
\end{lstlisting}

Note how we still need to define the number of variables, objectives, and constraints in addition to defining the \java{newSolution} method.  However, we no longer include the \java{evaluate} method.  Instead, we reference the executable we previously created on line 8.  The MOEA Framework will launch the executable and use it to evaluate solutions to the problem.

Our work is now complete.  We can now solve this ``external'' version of the Kursawe problem just like the pure Java implementation shown earlier in this chapter.

\begin{lstlisting}[language=Java]
new Executor()
		.withProblemClass(ExternalKursawe.class)
		.withAlgorithm("NSGAII")
		.withMaxEvaluations(10000)
		.run();
\end{lstlisting}

\begin{tip}
It is helpful to test the C/C++ program manually prior to running it with the MOEA Framework.  Tests can be performed by launching the C/C++ program and manually typing in inputs.  In this example, the program requires 3 real values entered on a single line.
\end{tip}

\begin{lstlisting}[language=Plaintext]
-2.5 1.25 0.05
\end{lstlisting}

Once the enter key is pressed, the program will output the two objectives to the console:

\begin{lstlisting}[language=Plaintext]
-13.504159423733775 6.966377092192072
\end{lstlisting}

Additional inputs can be provided, or press Ctrl+D to terminate the program.

\section{Scripting Language}
Problems can also be defined in one of the many scripting languages available via the Java Scripting API.  Supported languages include Javascript, Python, Ruby, Scheme, Groovy and BeanShell.  Java SE 6 includes Rhino, a Javascript scripting engine, out-of-the-box.  The following code snippet shows the Rhino Javascript code for defining the Kursawe problem.

\begin{lstlisting}[language=JavaScript]
importPackage(java.lang);
importPackage(Packages.org.moeaframework.core);
importPackage(Packages.org.moeaframework.core.variable);

function getName() {
	return "Kursawe";
}

function getNumberOfVariables() {
	return 3;
}

function getNumberOfObjectives() {
	return 2;
}

function getNumberOfConstraints() {
	return 0;
}

function evaluate(solution) {
	x = EncodingUtils.getReal(solution);
	f1 = 0.0;
	f2 = 0.0;

	for (i = 0; i < getNumberOfVariables() - 1; i++) {
		f1 += -10.0 * Math.exp(-0.2 * Math.sqrt(
				Math.pow(x[i], 2.0) + Math.pow(x[i+1], 2.0)));
	}
 
	for (i = 0; i < getNumberOfVariables(); i++) {
		f2 += Math.pow(Math.abs(x[i]), 0.8) +  
				5.0 * Math.sin(Math.pow(x[i], 3.0));
	}
 
	solution.setObjective(0, f1);
	solution.setObjective(1, f2);
}

function newSolution() {
	solution = new Solution(getNumberOfVariables(), 
			getNumberOfObjectives());
 
	for (i = 0; i < getNumberOfVariables(); i++) {
		solution.setVariable(i, new RealVariable(-5.0, 5.0));
	}
 
	return solution;
}

function close() {

}
\end{lstlisting}

Note how all methods defined by the \class{Problem} interface appear in this code.  Also note how we can invoke Java methods and constructors through the scripting language.  The specifics of how to implement functions and invoke existing methods are specific to the scripting language chosen.  Refer to the documentation for the scripting language for details.

Save this script to an appropriate file with the correct file extension for the scripting language.  Since the script in this example is written in the Rhino Javascript language, we save the file to \file{kursawe.js}.  Solving this Javascript version of the Kursawe problem is nearly identical to all previous examples, as shown below.

\begin{lstlisting}[language=Java]
new Executor()
		.withProblemClass(ScriptedProblem.class, 
				new File("kursawe.js"))
		.withAlgorithm("NSGAII")
		.withMaxEvaluations(10000)
		.run();
\end{lstlisting}

The only difference is on lines 2-3, where we specify the problem class as \java{ScriptedProblem.class} and pass as an argument the file \file{kursawe.js}.  The \java{ScriptedProblem} class loads the file, determines the appropriate scripting engine, and uses that scripting engine to evaluate solutions to the problem.

\section{Conclusion}
This chapter introduced the various means for introducing new problems to the MOEA Framework.  This includes implementing problems in Java, C/C++, and in one of the many supported scripting languages.  Care must be taken when choosing which language to use, as each method has different advantages and drawbacks.  One key consideration is the speed of each method.  The table below shows the wall-clock time for the three methods discussed in this chapter.  These times were produced on an Intel\copyright Core\texttrademark 2 Duo @ 2.13 GHz.

\par
\begin{center}
\begin{tabular}{ll}
  Method & Time (Seconds) \\
  \hline
  Java & 1.218 \\
  C/C++ & 4.011 \\
  Scripted (Javascript) & 24.874
\end{tabular}
\end{center}

Observe that using C/C++ incurs an overhead of approximately $0.000278$ seconds per evaluation.  For the simple Kursawe problem used as the example throughout this chapter, the overhead outweighs the evaluation time.  One would expect, however, that larger and more complex problems will benefit from potentially faster C/C++ implementations.  Furthermore, as one would expect, the scripted implementation in Javascript incurs a significant performance penalty.
